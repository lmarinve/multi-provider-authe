<!DOCTYPE html>
<html>
<head>
    <title>PKCE Test - Fixed Implementation</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem;
            line-height: 1.6;
        }
        .test-section {
            background: #f5f5f5;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 8px;
        }
        .result {
            background: #e8f5e8;
            padding: 1rem;
            border-radius: 4px;
            margin: 0.5rem 0;
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .error {
            background: #ffe8e8;
            color: #c00;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            margin: 0.25rem;
        }
        button:hover {
            background: #0056b3;
        }
        .valid { color: #28a745; font-weight: bold; }
        .invalid { color: #dc3545; font-weight: bold; }
    </style>
</head>
<body>
    <h1>PKCE Implementation Test - Fixed Version</h1>
    <p>This tests our corrected PKCE implementation that should work with CILogon.</p>
    
    <div class="test-section">
        <h2>Step 1: Generate Code Verifier</h2>
        <button onclick="testCodeVerifier()">Generate & Test Verifier</button>
        <div id="verifier-result"></div>
    </div>
    
    <div class="test-section">
        <h2>Step 2: Generate Code Challenge</h2>
        <button onclick="testCodeChallenge()">Generate Challenge from Verifier</button>
        <div id="challenge-result"></div>
    </div>
    
    <div class="test-section">
        <h2>Step 3: Round-trip Test</h2>
        <button onclick="testRoundTrip()">Test Complete PKCE Flow</button>
        <div id="roundtrip-result"></div>
    </div>
    
    <div class="test-section">
        <h2>Step 4: Test with Real CILogon URL</h2>
        <button onclick="testRealAuthURL()">Generate Real Auth URL</button>
        <button onclick="openAuthWindow()">Open CILogon (Test Mode)</button>
        <div id="auth-result"></div>
    </div>

    <script>
        let currentVerifier = '';
        let currentState = '';
        
        // Fixed PKCE implementation matching our updated provider
        function generateCodeVerifier() {
            // Generate 64 bytes = 86 base64url chars (well within spec, no padding issues)
            const array = new Uint8Array(64);
            crypto.getRandomValues(array);
            // Convert to base64url (no padding)
            return btoa(String.fromCharCode(...array))
                .replace(/\+/g, "-")
                .replace(/\//g, "_")
                .replace(/=+/g, ""); // Remove all padding for URL safety
        }
        
        function generateState() {
            const array = new Uint8Array(32);
            crypto.getRandomValues(array);
            return btoa(String.fromCharCode(...array))
                .replace(/\+/g, "-")
                .replace(/\//g, "_")
                .replace(/=+/g, "");
        }
        
        async function generateCodeChallenge(verifier) {
            // Generate challenge: base64url(SHA-256(UTF-8 bytes of code_verifier))
            const digest = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(verifier));
            return btoa(String.fromCharCode(...new Uint8Array(digest)))
                .replace(/\+/g, "-")
                .replace(/\//g, "_")
                .replace(/=+/g, "");
        }
        
        function validateVerifier(verifier) {
            const validChars = /^[A-Za-z0-9\-._~]+$/;
            const validLength = verifier.length >= 43 && verifier.length <= 128;
            return {
                validChars: validChars.test(verifier),
                validLength,
                length: verifier.length,
                value: verifier
            };
        }
        
        function testCodeVerifier() {
            const verifier = generateCodeVerifier();
            currentVerifier = verifier;
            const validation = validateVerifier(verifier);
            
            const resultDiv = document.getElementById('verifier-result');
            resultDiv.innerHTML = `
                <div class="result">
Generated Verifier: ${verifier}

Length: ${validation.length} chars ${validation.validLength ? '<span class="valid">✓ VALID</span>' : '<span class="invalid">✗ INVALID</span>'}
Characters: ${validation.validChars ? '<span class="valid">✓ VALID</span>' : '<span class="invalid">✗ INVALID</span>'}
RFC 7636 Compliant: ${validation.validChars && validation.validLength ? '<span class="valid">✓ YES</span>' : '<span class="invalid">✗ NO</span>'}
                </div>
            `;
        }
        
        async function testCodeChallenge() {
            if (!currentVerifier) {
                document.getElementById('challenge-result').innerHTML = '<div class="result error">Generate a verifier first!</div>';
                return;
            }
            
            const challenge = await generateCodeChallenge(currentVerifier);
            
            // Verify by regenerating
            const verifyChallenge = await generateCodeChallenge(currentVerifier);
            const matches = challenge === verifyChallenge;
            
            const resultDiv = document.getElementById('challenge-result');
            resultDiv.innerHTML = `
                <div class="result">
Using Verifier: ${currentVerifier}

Generated Challenge: ${challenge}
Challenge Length: ${challenge.length} chars
Verification Test: ${matches ? '<span class="valid">✓ CONSISTENT</span>' : '<span class="invalid">✗ INCONSISTENT</span>'}

Process:
1. UTF-8 encode verifier string
2. SHA-256 hash the encoded bytes
3. Base64URL encode the hash (no padding)
                </div>
            `;
        }
        
        async function testRoundTrip() {
            // Generate fresh values
            const verifier = generateCodeVerifier();
            const state = generateState();
            const challenge = await generateCodeChallenge(verifier);
            
            currentVerifier = verifier;
            currentState = state;
            
            // Store in sessionStorage like our app does
            const pkceMap = JSON.parse(sessionStorage.getItem('test_pkce') || '{}');
            pkceMap[state] = verifier;
            sessionStorage.setItem('test_pkce', JSON.stringify(pkceMap));
            sessionStorage.setItem('test_active_state', state);
            
            // Retrieve and verify
            const retrievedMap = JSON.parse(sessionStorage.getItem('test_pkce') || '{}');
            const retrievedVerifier = retrievedMap[state];
            const retrievedState = sessionStorage.getItem('test_active_state');
            
            const verifierMatches = retrievedVerifier === verifier;
            const stateMatches = retrievedState === state;
            
            const resultDiv = document.getElementById('roundtrip-result');
            resultDiv.innerHTML = `
                <div class="result">
Original State: ${state}
Original Verifier: ${verifier}
Generated Challenge: ${challenge}

Storage Test:
State Retrieval: ${stateMatches ? '<span class="valid">✓ MATCHES</span>' : '<span class="invalid">✗ MISMATCH</span>'}
Verifier Retrieval: ${verifierMatches ? '<span class="valid">✓ MATCHES</span>' : '<span class="invalid">✗ MISMATCH</span>'}

Ready for Token Exchange: ${verifierMatches && stateMatches ? '<span class="valid">✓ YES</span>' : '<span class="invalid">✗ NO</span>'}
                </div>
            `;
        }
        
        async function testRealAuthURL() {
            if (!currentVerifier || !currentState) {
                await testRoundTrip(); // Generate fresh values
            }
            
            const challenge = await generateCodeChallenge(currentVerifier);
            
            const params = new URLSearchParams({
                response_type: 'code',
                client_id: 'cilogon:/client_id/e33e29a20f84e0edd144d1e9a6e2b0',
                redirect_uri: 'https://lmarinve.github.io/multi-provider-authe/auth/callback/cilogon',
                scope: 'openid',
                state: currentState,
                code_challenge: challenge,
                code_challenge_method: 'S256'
            });
            
            const authUrl = `https://cilogon.org/authorize?${params.toString()}`;
            
            const resultDiv = document.getElementById('auth-result');
            resultDiv.innerHTML = `
                <div class="result">
Generated Auth URL:
${authUrl}

Parameters:
- response_type: code
- client_id: cilogon:/client_id/e33e29a20f84e0edd144d1e9a6e2b0
- redirect_uri: https://lmarinve.github.io/multi-provider-authe/auth/callback/cilogon
- scope: openid
- state: ${currentState}
- code_challenge: ${challenge}
- code_challenge_method: S256

Verifier stored for state "${currentState}": ${currentVerifier}
                </div>
            `;
        }
        
        function openAuthWindow() {
            if (!currentVerifier || !currentState) {
                alert('Generate auth URL first!');
                return;
            }
            
            testRealAuthURL().then(() => {
                const challenge = generateCodeChallenge(currentVerifier);
                challenge.then(ch => {
                    const params = new URLSearchParams({
                        response_type: 'code',
                        client_id: 'cilogon:/client_id/e33e29a20f84e0edd144d1e9a6e2b0',
                        redirect_uri: 'https://lmarinve.github.io/multi-provider-authe/auth/callback/cilogon',
                        scope: 'openid',
                        state: currentState,
                        code_challenge: ch,
                        code_challenge_method: 'S256'
                    });
                    
                    const authUrl = `https://cilogon.org/authorize?${params.toString()}`;
                    console.log('Opening auth URL:', authUrl);
                    console.log('Stored verifier for state', currentState, ':', currentVerifier);
                    
                    // Store the verifier properly before opening
                    const pkceMap = JSON.parse(sessionStorage.getItem('test_pkce') || '{}');
                    pkceMap[currentState] = currentVerifier;
                    sessionStorage.setItem('test_pkce', JSON.stringify(pkceMap));
                    
                    window.open(authUrl, 'test-auth', 'width=600,height=700');
                });
            });
        }
        
        // Listen for messages from auth popup
        window.addEventListener('message', (event) => {
            if (event.data.type === 'CILOGON_AUTH_SUCCESS') {
                const returnedState = event.data.state;
                const returnedCode = event.data.code;
                
                // Get our stored verifier
                const pkceMap = JSON.parse(sessionStorage.getItem('test_pkce') || '{}');
                const storedVerifier = pkceMap[returnedState];
                
                console.log('Auth callback received:');
                console.log('- State:', returnedState);
                console.log('- Code:', returnedCode);
                console.log('- Stored verifier:', storedVerifier);
                
                if (storedVerifier) {
                    alert(`Success! Code received and verifier matched.\nState: ${returnedState}\nVerifier found: ${storedVerifier.substring(0, 20)}...`);
                } else {
                    alert(`Error: No verifier found for state ${returnedState}`);
                }
            }
        });
        
        // Auto-run basic tests on load
        window.addEventListener('load', () => {
            testCodeVerifier();
        });
    </script>
</body>
</html>